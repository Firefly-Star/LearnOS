# xv6-riscv学习笔记

### 计算机体系架构的分层，操作系统开发的方法

    开发者首先在主机系统（通常是 x86 或 ARM 等常见架构的电脑）上编写源代码，这些代码可以是操作系统内核、应用程序或硬件驱动等。源代码通常采用高级编程语言（如 C、C++、汇编语言等）。

    交叉编译器是一个在一种平台上（通常是开发主机平台）生成另一种平台（目标硬件架构）上可以执行的二进制代码的工具链。交叉编译器会将开发主机的架构与目标架构区分开来。

    在主机上，使用交叉编译工具链将源代码编译为目标平台所需的二进制文件。

    编译好的二进制文件通常会被部署到目标硬件中，可能通过多种方式传输（如通过串口、网络、SD 卡等）。在目标硬件上，通常没有完整的操作系统环境，可能只运行一个引导程序（如 bootloader），该程序负责加载内核、驱动等。

    目标硬件接收到二进制代码后，可以直接运行（如果是裸机环境）。在有操作系统的环境下，加载的代码将被操作系统调度和管理，执行相应的任务。

    生成二进制文件的工具（如交叉编译器、链接器等）通常由硬件厂商、开源社区或第三方工具提供，并且这些工具针对特定硬件架构进行优化或定制。

    也就是说，（最基础的）编译工具是先于操作系统的，反过来，在操作系统完成之后，编译工具也需要针对操作系统实现的系统调用和一些特定进行对应的优化。

### 为什么能用C语言来写操作系统代码，如何理解"操作系统就是C语言程序"

    与其说为什么能用C语言来写操作系统代码，不如说，一个能用来开发操作系统的语言，需要有哪些特征？

        1. 直接硬件访问
        能够操作硬件资源：内核语言需要能够直接访问和控制硬件资源，如 CPU 寄存器、内存、I/O 端口、硬盘等。这要求编程语言能够生成低级的机器指令（如汇编语言）或提供与硬件直接交互的能力。

        2. 高效的内存管理
        内存控制：操作系统内核需要精确控制内存分配和回收，包括内存分页、物理内存与虚拟内存的映射、堆栈管理等。语言本身需要支持低级内存操作，如指针操作、内存分配和释放。

        3. 性能要求
        高效性：内核代码要求高效的执行，因为内核直接参与系统的调度、资源管理等核心操作。编  程语言需要支持低开销、快速执行，以确保内核响应速度。
        
        实时性：在许多情况下，操作系统内核必须满足实时性要求（例如中断响应、任务调度）。因  此，语言需要允许开发者写出高效、可预测的代码。
        
        4. 没有操作系统依赖
        无运行时依赖：内核开发语言必须能够在没有操作系统支持的环境中运行。在编写内核时，不能依赖操作系统的库函数或运行时环境（如标准库、线程库等）。这意味着语言应尽量避免使用动态内存分配、文件操作等高级功能。
        
        裸机环境支持：编程语言必须能够在“裸机”环境中工作，即没有操作系统的支持，直接在硬件上执行。
        5. 可移植性
        跨平台支持：虽然内核需要硬件控制，但也希望支持多个架构（如 x86、ARM、RISC-V）。开发语言需要能够支持不同的体系结构，并且可以通过合适的交叉编译器生成适用于不同平台的 代码。
    
    综上，操作系统为什么常用C语言来写，就很显而易见了。
    
    同理，操作系统程序和普通C语言程序的最大差距，也在于：操作系统程序一定不能依赖于运行时库。

### xv6-riscv的一些文件格式及其作用

    .c, .h, .o, .S：
        无需多言

    .d：
        依赖文件，描述源文件与其依赖项之间的关系。例如 一个 .d 文件可能包含以下内容：
        main.o: main.cpp main.h utils.h

        其作用为增量编译，构建工具根据依赖关系来判断头文件是否发生了变化，从而决定是否重新编译对应的源文件。上述例子中，main.cpp main.h utils.h其中任何一个文件改变，main.o 都需要重新生成。

    .ld:
        链接脚本文件，用于定义链接时，不同的代码段所装载的内存位置。在sv6-riscv中，kernel.ld非常简短，大概就是定义了整个程序的入口(entry.S)，并且定义了各个代码段的别名，对齐方式等。

        kernel.ld中定义了代码段从0x80000000开始，其中代码段以4kB对齐，只读数据，数据，未初始化数据段以16B对齐，接下来就是end(内存管理中的初始地址)

    MakeFile：
        无需多言，唯一需要注意的是，MakeFile中，指定了kernel和user是分开编译的。这也让两个程序的代码可以有重定义的部分。

### xv6-riscv的启动过程

    kernel.ld定义了整个操作系统程序的入口entry.S。
    
    操作系统启动时，此时处于权限最高的机器模式(Machine Mode)。从entry.S进入，进行栈的分配后，然后进入start.c的start()。

    在start()中，首先将mstatus的mpp位(中断返回后的特权级)设置为权限较低的监管模式(Supervisor Mode)，然后设置epc(中断返回的程序执行位置)为main的函数指针，进行了一些设置后，最后执行mret，进入监管模式并且运行main。

        补充：mstatus是非常重要的寄存器，保存了cpu的状态，它的内存结构如下：

        31          23 22 |21| 20 |19|18| 17 |16|15| 14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0
        +---------------+---+---+----+---+---+----+---+---+---+---+---+---+---+---+---+---+---+---+---+
        |     ...       | U | S | H  |   | F | MSA| MIE| MPIE| SIE| SPIE|  ... | MPP | MPRV | XS | FS | MIE |
        +---------------+---+---+----+---+---+----+---+---+---+---+---+---+---+---+---+---+---+---+---+

        1. MIE (Bit 3):
            Machine Interrupt Enable. 这个位表示机器模式下的中断是否使能。
        2. MPIE (Bit 7):
            Machine Previous Interrupt Enable. 当中断被关闭时，该位保存中断使能状态，以便在中断返回时恢复。
        3. SIE (Bit 1):
            Supervisor Interrupt Enable. 这个位表示监管模式下的中断使能状态。
        4. SPIE (Bit 5):
            Supervisor Previous Interrupt Enable. 当监管中断被关闭时，该位保存以前的监管中断使能状态以便恢复。
        5. MPP (Bits 11-10):
            Machine Previous Privilege. 这两位表示mret后所需要设置的特权级别，可以是：
                00: User Mode
                01: Supervisor Mode
                11: Machine Mode
        6. MPRV (Bit 17):
            Machine Privilege Level. 这是一个控制位，指示使用不同的地址空间（例如，系统级别的页面映射）。
        7. XS (Bits 19-18):
            Extension Status. 这一对位用于状态指示，通常与支持的扩展相关。
        8. FS (Bits 22-20):
            Floating Point Status. 这部分用于表示浮点单元的状态。
        9. U (Bit 23):
            User Mode. 表示用户模式下的某些状态。
        10. S (Bit 24):
            Supervisor Mode. 表示当前处于监管模式。
        11. H (Bit 25):
        Hypervisor Mode. 表示当前处于虚拟化环境中（如果支持）。
    
    然后进入main，根据不同的cpuid来进入不同的分支，进行初始化，然后进入schdule进行进程调度。

### gcc的一些特性

    1. 原子内建函数：
        见gcc手册相应内容(https://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Atomic-Builtins.html)

        虽然该文档是x86的，但是riscv的实现应当也大差不差(应该吧)

    2. __attribute__((x))
        x：注解，表示程序员的一些承诺，允许编译器的优化。类似cpp11后的[[x]]注解

### riscv架构

    32个用户态的通用寄存器。详情见计组(论计组为什么是神)。

    3个状态：M,S,U。
        机器模式主要用于启动和定时器中断。

        内核代码全部运行在监管模式。
        
        用户程序全部运行在用户模式。

    除了通用寄存器外，还有许多控制和状态寄存器CSRs(Control and Status Registers)。这些寄存器是用户模式无法访问的。riscv支持非常多的CSR，其中有19个是很重要的。m开头表示只有机器模式可访问，而s开头表示机器和监管模式都可访问。
        1. mhartid:     hart(cpu)id
        2. m(s)status:  status register，其中有SIE(是否开中断),SPIE(中断前是否开中断),SPP(中断前的模式,S、U)。可以通过sie来暂时地关中断。
        3. m(s)tvec：   陷阱向量表
        4. m(s)epc:     previous exception PC
        5. scause:      trap cause code
        6. m(s)scratch: 指向异常处理或上下文切换的私有存储区域
        7. satp:        addr translation ptr(指向页表的指针)
        8. m(s)ie:      interrupt enable(中断标志寄存器)
        9. sip:         interrupt pending(待处理中断)
        10. medeleg:    exception delegation(指派异常下放的位掩码，实际只有16个有效位)
        10. mideleg:    exception delegation(指派中断下放的位掩码，实际只有16个有效位)
        11. pmpcfg0:    限制监管模式和用户模式对物理地址的访问
        12. pmpaadr0:   限制监管模式和用户模式对物理地址的访问 
        13. stval:      bad addr or instruction
        14. m(s)ie:     选择性地开关某个中断的位掩码寄存器

### 自旋锁：spinlock.c

    很简单的一个实现，在获取锁时会先给对应的cpu关中断，然后用gcc的内置函数调用riscv的一个原子操作amoswap来检查是否已经被上锁，在释放时同样调用原子操作来解锁。

    值得注意的是，当一个cpu上运行的进程申请了自旋锁时，它会进入关中断状态，直到该进程的所有锁都被释放后，才会重新开中断，在此期间不允许进程的调度等。

### 内存分配：kalloc.c

    所有内存分配基于4KB大小的页。

    上述提到过，可用内存的起始物理地址end来源于kernel.ld，而终止物理地址(PHYSTOP)被硬编码为0x80000000 + 128 * 1024 * 1024，即操作系统内核的代码段，数据段和可用内存，总计128MB。

    内存的布局详见memlayout.h。

    分配内存页(kalloc)就是简单地获得锁，然后取出kmem中空闲内存页链表freelist的表头，然后释放锁，返回指针。一整页的数据会被设置为5(junk data)。

    释放内存页(kfree)的操作就是检查指针是否对齐，是否在范围内，然后将它里面的数据设置为1(junk data)，然后将它插入kmen中freelist的表头。

    这里的junk data似乎有点像cpp stl中卫兵值的概念，标识数据结构的边界，一定程度上防止越界访问。

    内存分配的初始化就是将对齐后的起始内存和终止内存之间的内存页都进行kree的操作。

### 系统调用：user.h

    user.h中声明了21个已有的系统调用和一些简单的库函数。
        库函数的实现在ulib.c中。
        系统调用的实现在usys.S中。它实际上是由usys.pl脚本通过perl工具生成的。
    
    syscall.h中声明了21个系统调用号的宏。

    usys.S做的事情是将系统调用号装入a7寄存器中，然后调用ecall进行系统调用。

### riscv页表

    xv6采用的是3级页表，上面说过，每一页的大小为硬编码的4KB。

    虚拟地址(64bit, 8B)中，高25位无效，有效位数为39位，被分为9,9,9,12，分别为一级页表，二级页表，三级页表，页内地址。

    页表中的每一条记录(64bit, 8B)中，高10位无效，有效位数为54位，被分为44,10，分别为物理页号和标志位。
        标志位的低位：U，X，W，R，V。

        物理页号将和虚拟地址的末12位组合成一个56位的物理地址。

    详情见https://blog.csdn.net/MCQSW/article/details/135172606

### riscv陷阱处理(trap processing)
    riscv的陷阱(trap)被分为中断(interrupt)和异常(exception)，其中中断是同步的，是对硬件或系统事件的响应，异常是异步的，是对程序内部错误或特定事件的响应。

    当出现陷阱时，如果是中断，则会根据sstatus中的sie位来判断是否要处理，还是将它置为待处理，如果是异常，则不受sie控制，它一定会被捕捉和正确处理。

    监管模式下的陷阱处理时，硬件做的事情：
        1. PC -> sepc: 保存陷阱前的下一条指令的地址
        2. stvec -> PC: 进入陷阱处理
        3. 陷阱原因 -> scause, 额外信息 -> stval: 保存陷阱原因和额外信息
        4. 陷阱前的模式 -> sstatus.SPIE, 陷阱前的sstatus.sie -> sstatus.spie: 保存陷阱前的模式和是否开中断
        5. sstatus.SIE = 0: 关中断
        6. mode = supervisor: 模式设置成监管模式
        7. 最后进入陷阱处理

    陷阱返回的流程(sret):
        sstatus.SPIE -> sstatus.SIE, sstatus.SPP -> mode, sepc -> PC

    机器模式下的陷阱处理基本一致。唯一区别是mstatus中MPP位有2位。机器模式下处理的唯一中断是计时器中断，其他中断将被委托(delegate)给监管模式。计时器中断将被转换成一个软中断，在监管模式触发一个中断。这一点还不太懂。

    而在xv6的实现中，陷阱的处理是这样的：
        1. 执行上述的硬件操作，会将stvec的值装入PC中，实际上就是跳入第二步的uservec做的准备。stvec(64bit, 8byte)的值是操作系统在初始化时装入的。
        2. 进入uservec(trampoline.S中)，保存用户模式的通用寄存器，加载内核的通用寄存器，将内核的页表装入satp中，跳转至usertrap.c。
        3. 运行usertrap.c，陷阱处理结束后调用usertrapret.c。
        4. 调用userret(trampoline.S中)，基本就是uservec的逆过程。
        5. 最后调用sret，即执行上述硬件的一些行为。
        
        值得注意的是，这里的2和5是在用户的地址空间中完成的。另外，这一系列的处理工作流与函数的调用很像，但是实际上这些调用都是不会返回的。

### xv6 memlayout
    每个用户模式的虚拟地址空间(即进程)的最顶部有trampoline和trapframe。
    
    trampoline是一块代码(包含uservec和userret)，用于快速转移到特定的处理程序或特定的代码上下文中，通常用于处理中断和异常。它的权限是可读，可执行，不可被用户模式访问。

    trapframe 是在发生中断或异常时用来保存处理过程中的寄存器状态和上下文的一种数据结构。它通常是一个结构体，包含了所有需要保存的寄存器值，以便在中断处理完成后能够恢复之前的执行状态。它的权限是可读，可写，用户模式不可访问。

    在xv6的布局中，二者各占一页的内存(4KB)。所有的trampoline都被映射到同一个物理地址。所有的trapframe被映射到不同的物理地址。

    具体的memlayout见memlayout.h。

    内核空间的虚拟地址就是物理地址，不管是否开启了虚拟寻址。
### proc.h
    struct context:上下文结构体

    riscv的寄存器分为两类，调用者保存寄存器（caller-saved registers）和被调用者保存寄存器（callee-saved registers）。上下文结构体中，只保存了被调用者保存寄存器，即由被调用者来确保不变的寄存器(s0-s11)。

    struct cpu: rt，里面有当前正在运行的proc结构体，上下文结构体，关中断深度，在关中断之前是否允许中断的信息。

    struct trapframe: 它是一个内存页，具体构造详见代码。

    struct proc: 里面有一个枚举类state, 包括{ UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE }，有个锁，用于访问进程状态的一致性。具体构造详见代码。值得注意的是，其中的trapframe*指向的是陷阱内存帧的物理地址，我们只会在内核模式下使用这个指针。
### trampoline.S和trap.c
    trampoline.S中有uservec和userret两个汇编函数，它们kernel.ld被安放在内核代码块最后的位置，且被分配了一个内存页。

    uservec要做的大致就是让，将a0保存至sscratch，让a0指向trapframe，保存31个通用寄存器(除了硬件恒零的x0以外)，然后根据proc.h中trapframe的内存结构读取内核栈指针，cpu号，usertrap(下文介绍)的函数指针，内核页表的指针。

    需要注意的是，上述的汇编代码是运行在内核空间的虚拟地址空间的。同时，trapframe的最顶部的那些非寄存器的内存，是100%不会修改的。同时每次对内核模式程序上下文的初始化是不需要恢复上次运行内核模式程序上下文的寄存器的。

    接下来就会运行trap.c中的usertrap()。

    usertrap不会return。

    usertrap会根据scause寄存器中的值来判断trap的类型。
        当它为8时，就是系统调用，接下来会kill进程或者调用syscall()。
        
        否则，检查它是设备中断还是计时器中断。如果是计时器中断，则调用yield，重新进行进程调度。

    usertrap处理结束后会调用usertrapret。

    userret会在做了一些事情后调用userret。

    userret(uint64 pagetable)做的就是把uservec做的事情反过来做一遍，参数pagetable就是trapframe的首地址。

    userret最后会调用sret。

    系统调用的参数传递是通过risc-v的调用约定来实现的。a0-a6会由硬件来自动地进行参数装填，而a7需要装系统调用号，因此xv6自带的系统调用只能支持7个参数，每个参数不能超过8B。

### 进程调度:proc.c和swtch.S
    cpuid()，核心(hart, cpu, core)id，只是返回tp寄存器中的值。为了避免在查询过程中，进程被移到不同cpu中，必须在关中断后访问。

    mycpu()，根据cpuid来获得cpu。

    myproc()，根据cpuid来获得cpu，并且获得当前该cpu正在运行的进程。

    yield()，它会在每次的定时器中断中被调用。把当前cpu中目前正在运行的进程从RUNNING改成RUNNABLE，即停止运行。然后调用sched()。

    sched()首先做一些检查，然后保存cpu的intena字段，最后调用swtch(struct context *old, struct context *new)，它在swtch.S中。

    swtch所做的事情就是把除了ax和tx寄存器以外的寄存器给存放到old指向的context中，并将new指向的context给加载到寄存器中。

    值得注意的是，进程的context结构体中含有ra寄存器，即函数返回的地址，而swtch改变了context后，它最后调用ret会返回到new context中的返回地址。

    scheduler()，它遵循的就是简单的时间片调度，且先进先出。

    值得注意的是，scheduler在找到了新的可运行进程后会直接通过swtch来保存目前的上下文并直接切换到该进程，不会return。